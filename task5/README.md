# inf/task5-rational-calc

1. Подготовьте каталог task5 в каталоге ```inf```.
2. Разработайте модуль для представления рациональных чисел.
   - Разместите заголовочный файл модуля ```rational.h```:
        ```c
       #ifndef RATIONAL_H
       #define RATIONAL_H

       typedef struct {
           int num;
           unsigned int denom;
       } rational_t;

       /*
       * Возвращает рациональное число, получаемое как результат деления
       * n на d.
       */
       rational_t rational(long n, long d);

       /*
       * Возвращает числитель рационального числа r.
       */
       long rat_num(rational_t r);

       /*
       * Возвращает знаменатель рационального числа r.
       */
       long rat_denom(rational_t r);

       #endif
       ```
     Прототипы функций ```rational()```, ```rat_num()``` и ```ran_denom()``` определяют абстрактный тип данных рационального числа.

   - Создайте файл ```rational.c``` с реализацией этих функций. Функция-конструктор ```rational()``` должна выполнять сокращение дроби и учитывать знак числа в числителе, а также приводить нулевое значение числа к каноническому виду. Для поиска наибольшего общего делителя при сокращении дроби рекомендуется использовать алгоритм Эвклида.

3. Разработайте модуль ```rat_math``` для выполнения арифметических операций с рациональными числами. Модуль должен предоставлять функции ```rat_add()```, ```rat_sub()```, ```rat_mul()``` и ```rat_div()``` и использовать только операции АТД рационального числа, избегая непосредственного обращения к полям структуры.

   Пример реализации функции суммирования:
    ```c
    rational_t rat_sum(rational_t a, rational_t b) {
        return rational(rat_num(a) * rat_denom(b) + rat_num(b) * rat_denom(a),
                        rat_denom(a) * rat_denom(b));
    }
    ```

4. Разработайте модуль ```rat_io```, предоставляющий функции для преобразования из строки и для вывода рациональных чисел. Функция вывода не должна печатать знаменатель, если он равен 1 (число является целым). Для разбора строки может быть удобно использовать функцию ```sscanf()```.

5. Разработайте программу калькулятора ```calc```, используя модули ```rat_io``` и ```rat_math```.
   Таким образом, разработанная программа будет включать 3 уровня абстракции:
   - Реализация АТД рационального числа.
   - Функции для работы с рациональными числами.
   - Текстовый пользовательский интерфейс калькулятора.

6. Обеспечьте сборку модулей для работы с рациональными числами в виде статической или (по желанию) динамической разделяемой библиотеки и использование этой библиотеки в программе ```calc```.

   Статическая библиотека включается в исполняемый файл на этапе компоновки. Динамическая библиотека подключается при загрузке программы.
   1. Создайте подкаталог ```rational``` и перенесите в него исходные файлы модулей ```rational```, ```rat_math``` и ```rat_io```.
   2. Создайте в каталоге ```rational``` файл ```Makefile``` для сборки модулей библиотеки, напишите правила для сборки объектных файлов всех модулей.
   3. Добавьте правило для сборки библиотеки ```librational```. Для создания статической библиотеки librational.a можно использовать правило:
       ```Makefile
       librational.a: rational.o rat_math.o rat_io.o
           ar -rcs librational.a rational.o rat_math.o rat_io.o
       ```
      Команда ```ar``` создает архив с указанными объектными файлами.
      Или для сборки динамической библиотеки можно использовать:
       ```Makefile
       librational.so: rational.o rat_math.o rat_io.o
           gcc -shared -o librational.so rational.o rat_math.o rat_io.o
       ```
      Для динамической библиотеки также необходимо добавить ключ ```-fPIC``` к командам ```gcc```, которые используются для сборки составляющих библиотеку объектных файлов.
   4. В ```Makefile``` в базовом каталоге задания определите правило для сборки объектного файла ```calc.o``` и исполняемого файла calc. При сборке исполняемого файла нужно подключить созданную библиотеку:
       ```Makefile
       calc: rational calc.o
           gcc -g -o calc calc.o -L./rational -lrational
       ```

      Эта команда будет работать как для статической, так и для динамической библиотеки.

   5. В Makefile для программы ```calc``` добавьте цель ```rational``` с вызовом make для сборки библиотеки в подкаталоге.
       ```Makefile
       .PHONY: rational
       rational:
           cd rational && $(MAKE)
       ```

      Строчка ```.PHONY: rational``` делает цель ```rational``` фиктивной, чтобы она выполнялась независимо от существования и времени изменения файла или каталога с таким же именем.

7. Проверьте сборку и выполнение программы. Подготовьтесь ответить на вопросы инструктора и сдайте работу. Если используется динамическая библиотека, при запуске программы возникнет ошибка:

    ```
    $ ./calc
    ./calc: error while loading shared libraries: librational.so: cannot open shared object file: No such file or directory
    ```

   Решение — указать путь поиска для библиотек:

    ```
    $ LD_LIBRARY_PATH=./rational ./calc
    ```